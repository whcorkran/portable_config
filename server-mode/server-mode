#!/usr/bin/env bash
#
# server-mode - script enabling easy access over ssh to idle machine without display overhead
#
# Architecture:
#   - Ephemeral State: /run/server-mode (tmpfs, reboot-safe)
#   - Detached Execution: systemd transient service (survives PTY death)
#   - Verified Operations: All critical steps are validated
#   - Resilience: Timeouts, rollbacks, and safe fallbacks
#   - Observability: journald integration via systemd-cat

set -euo pipefail

# ------------------------------------------------------------------------------
# Configuration (Override in /etc/default/server-mode)
# ------------------------------------------------------------------------------

readonly VERSION="1.0.0"
readonly SCRIPT_PATH="$(readlink -f "${BASH_SOURCE[0]}")"
readonly RUN_DIR="/run/server-mode"
readonly STATE_FILE="${RUN_DIR}/state"
readonly LOCK_FILE="/run/lock/server-mode.lock"
readonly TRANSITION_LOCK="/run/lock/server-mode-transition.lock"

# Defaults (can be overridden)
SAFETY_TIMEOUT="${SAFETY_TIMEOUT:-300}"  # 5 minutes for safety margin

# Load external config if present (before logging setup to catch errors)
if [[ -f /etc/default/server-mode ]]; then
    # shellcheck source=/dev/null
    if ! source /etc/default/server-mode 2>/dev/null; then
        echo "WARNING: Failed to load /etc/default/server-mode" >&2
    fi
fi

# ------------------------------------------------------------------------------
# Logging (Deferred to avoid breaking interactive prompts)
# ------------------------------------------------------------------------------

# Global flag to track if we should use journald
USE_JOURNALD=0

setup_logging() {
    # Only redirect to journald if non-interactive AND not already redirected
    if [[ ! -t 1 ]] && [[ "$USE_JOURNALD" -eq 0 ]]; then
        exec 1> >(systemd-cat -t server-mode)
        exec 2> >(systemd-cat -t server-mode -p err)
        USE_JOURNALD=1
    fi
}

log() { echo "INFO: $*"; }
err() { echo "ERROR: $*" >&2; }
ok()  { echo "OK: $*"; }
die() { err "$*"; exit 1; }

require_root() {
    if [[ "$EUID" -ne 0 ]]; then
        # Preserve only safe environment variables
        exec sudo \
            SSH_CONNECTION="${SSH_CONNECTION:-}" \
            SSH_CLIENT="${SSH_CLIENT:-}" \
            SSH_TTY="${SSH_TTY:-}" \
            "$0" "$@"
    fi
}

# ------------------------------------------------------------------------------
# Helpers
# ------------------------------------------------------------------------------

# Wait for PID with timeout (bash-native, no external timeout command)
wait_with_timeout() {
    local pid=$1
    local timeout_sec=$2
    local iterations=$((timeout_sec * 10))  # 0.1s per iteration
    local i=0

    while ((i < iterations)); do
        if ! kill -0 "$pid" 2>/dev/null; then
            # Process finished
            wait "$pid" 2>/dev/null
            return 0
        fi
        sleep 0.1
        ((i++))
    done

    # Timeout exceeded
    return 1
}

# ------------------------------------------------------------------------------
# Pre-flight Checks (delegated to external script)
# ------------------------------------------------------------------------------

preflight_check() {
    local check_script="$(dirname "$SCRIPT_PATH")/server-mode-check"

    if [[ ! -x "$check_script" ]]; then
        err "Pre-flight check script not found or not executable: $check_script"
        return 1
    fi

    # Run the external checker (it handles its own output)
    if "$check_script"; then
        return 0
    else
        return 1
    fi
}

# ------------------------------------------------------------------------------
# Safety Net (Process-Tracked Recovery)
# ------------------------------------------------------------------------------

engage_safety_net() {
    log "Arming safety net (${SAFETY_TIMEOUT}s timeout)..."

    # Store the PID of the transition service (will be set by systemd-run)
    # We use a marker file that the safety timer checks
    mkdir -p "$RUN_DIR"
    echo "armed" > "$RUN_DIR/safety_armed"

    # Clean up any previous instances
    systemctl stop server-mode-safety.timer &>/dev/null || true
    systemctl reset-failed server-mode-safety.service &>/dev/null || true

    # Create transient timer with process verification
    # Use single quotes to prevent premature expansion
    systemd-run \
        --unit=server-mode-safety \
        --on-active="$SAFETY_TIMEOUT" \
        --timer-property=AccuracySec=1s \
        --description="Server Mode Safety Restore" \
        /bin/bash -c '
            if [[ -f '"$RUN_DIR"'/safety_armed ]]; then
                logger -t server-mode "Safety restore triggered - timeout exceeded"
                systemctl isolate graphical.target
            else
                logger -t server-mode "Safety timer expired but already disarmed"
            fi
        '

    ok "Safety net armed"
}

disarm_safety_net() {
    rm -f "$RUN_DIR/safety_armed"
    systemctl stop server-mode-safety.timer &>/dev/null || true
}

# ------------------------------------------------------------------------------
# Core Transition Logic (Fully Detached & Verified)
# ------------------------------------------------------------------------------

transition_to_server() {
    # This function runs inside a systemd transient SERVICE (not scope)
    # It is fully detached from any terminal and will survive PTY death

    # Acquire transition lock (survives parent death)
    exec {tlock}>"$TRANSITION_LOCK" 2>/dev/null || return 1
    if ! flock -n "$tlock"; then
        log "Transition already in progress"
        return 1
    fi

    # Setup logging for detached execution
    setup_logging

    # Arm safety net if this was an SSH session
    if [[ "${WAS_SSH:-0}" == "1" ]]; then
        engage_safety_net
    fi

    # Write state file with verification
    if ! mkdir -p "$RUN_DIR"; then
        err "Cannot create state directory: $RUN_DIR"
        disarm_safety_net
        return 1
    fi

    # Use the passed-in TRIGGER_USER for accurate auditing
    if ! cat > "${STATE_FILE}.tmp" <<EOF
START_TIME=$(date +%s)
USER=${TRIGGER_USER:-root}
EOF
    then
        err "Cannot write state file (disk full?)"
        disarm_safety_net
        return 1
    fi

    if ! mv "${STATE_FILE}.tmp" "$STATE_FILE"; then
        err "Cannot finalize state file"
        rm -f "${STATE_FILE}.tmp"
        disarm_safety_net
        return 1
    fi

    # Perform the critical transition
    log "Isolating multi-user.target..."
    if ! systemctl isolate multi-user.target; then
        err "systemctl isolate failed!"
        rm -f "$STATE_FILE"
        disarm_safety_net
        return 1
    fi

    # CRITICAL: Verify the transition actually succeeded
    sleep 2  # Give systemd time to settle

    if ! systemctl is-active multi-user.target &>/dev/null; then
        err "multi-user.target is not active after isolation!"
        err "System may be in inconsistent state - attempting recovery..."
        systemctl isolate graphical.target
        rm -f "$STATE_FILE"
        disarm_safety_net
        return 1
    fi

    # Verify display manager actually stopped
    for dm in gdm gdm3 lightdm sddm lxdm; do
        if systemctl is-active "$dm" &>/dev/null; then
            err "Display manager $dm is still running after isolation!"
            err "Attempting recovery..."
            systemctl isolate graphical.target
            rm -f "$STATE_FILE"
            disarm_safety_net
            return 1
        fi
    done

    disarm_safety_net
    ok "Server mode active and verified"
    ok "multi-user.target active, display manager stopped"
}

transition_to_desktop() {
    # Acquire transition lock
    exec {tlock}>"$TRANSITION_LOCK" 2>/dev/null || return 1
    if ! flock -n "$tlock"; then
        log "Transition already in progress"
        return 1
    fi

    # Setup logging
    setup_logging

    # Clear state
    rm -f "$STATE_FILE"

    # Restore graphical target with timeout
    log "Isolating graphical.target..."

    # Use background process with bash-native timeout
    local isolate_pid
    systemctl isolate graphical.target &
    isolate_pid=$!

    if ! wait_with_timeout "$isolate_pid" 30; then
        err "Failed to restore graphical.target within 30 seconds!"
        err "System may be in inconsistent state"
        err "Manual recovery: sudo systemctl start gdm (or your display manager)"
        kill -9 "$isolate_pid" 2>/dev/null || true
        return 1
    fi

    ok "Desktop restored successfully"
}

# ------------------------------------------------------------------------------
# Command Handlers
# ------------------------------------------------------------------------------

cmd_on() {
    # Detect SSH session BEFORE sudo (environment won't be preserved perfectly)
    local is_ssh=0
    [[ -n "${SSH_CONNECTION:-}${SSH_CLIENT:-}${SSH_TTY:-}" ]] && is_ssh=1

    require_root on

    # Acquire command lock
    exec {lock}>"$LOCK_FILE" 2>/dev/null || die "Cannot create lock file"
    flock -n "$lock" || die "Another instance is already running"

    # Check if already in server mode
    if [[ -f "$STATE_FILE" ]]; then
        log "Already in server mode"
        exit 0
    fi

    # Run pre-flight checks (BEFORE logging redirect)
    log "Running pre-flight checks..."
    if ! preflight_check; then
        die "Pre-flight checks failed - aborting for safety"
    fi
    ok "Pre-flight checks passed"

    # Capture user for auditing
    local target_user="${SUDO_USER:-$USER}"
    [[ "$target_user" =~ ^[a-z_][a-z0-9_-]*$ ]] || target_user="unknown"

    log "Starting server mode transition..."

    # Execute transition in FULLY DETACHED systemd transient SERVICE
    # This survives terminal death, SIGHUP, and any PTY closure
    if ! systemd-run \
        --service-type=oneshot \
        --quiet \
        --wait \
        --collect \
        --setenv=WAS_SSH="$is_ssh" \
        --setenv=TRIGGER_USER="$target_user" \
        --unit=server-mode-transition \
        --description="Server Mode Transition" \
        /bin/bash -c "source '$SCRIPT_PATH'; transition_to_server"; then
        die "Transition failed"
    fi

    ok "Server mode enabled successfully"
}

cmd_off() {
    require_root restore

    exec {lock}>"$LOCK_FILE" 2>/dev/null || die "Cannot create lock file"
    flock -n "$lock" || die "Another instance is already running"

    log "Restoring desktop mode..."

    # Run in detached service
    if ! systemd-run \
        --service-type=oneshot \
        --quiet \
        --wait \
        --collect \
        --unit=server-mode-restore \
        --description="Server Mode Desktop Restore" \
        /bin/bash -c "source '$SCRIPT_PATH'; transition_to_desktop"; then
        die "Desktop restoration FAILED - manual recovery required"
    fi

    ok "Desktop mode restored successfully"
}

cmd_status() {
    echo "Server Mode Status (v$VERSION)"
    echo "----------------------------"

    if [[ -f "$STATE_FILE" ]]; then
        local start_time uptime
        start_time=$(awk -F= '/^START_TIME/ {print $2}' "$STATE_FILE" 2>/dev/null || echo "0")
        uptime=$(( $(date +%s) - start_time ))
        echo -e "State: \033[0;32mSERVER\033[0m (uptime: ${uptime}s)"

        local user
        user=$(awk -F= '/^USER/ {print $2}' "$STATE_FILE" 2>/dev/null || echo "unknown")
        echo "Activated by: $user"
    else
        echo -e "State: \033[0;34mDESKTOP\033[0m"
    fi
}

cmd_console() {
    # Pure bash interactive console - no ncurses dependencies
    local refresh_interval=2

    # Terminal control sequences
    local clear_screen=$'\033[2J\033[H'
    local bold=$'\033[1m'
    local dim=$'\033[2m'
    local green=$'\033[32m'
    local yellow=$'\033[33m'
    local blue=$'\033[34m'
    local cyan=$'\033[36m'
    local red=$'\033[31m'
    local reset=$'\033[0m'

    # Hide cursor, restore on exit
    tput civis 2>/dev/null
    trap 'tput cnorm 2>/dev/null; echo' EXIT

    while true; do
        # Gather system info
        local state="DESKTOP"
        local state_color="$blue"
        local uptime_str="—"
        local activated_by="—"

        if [[ -f "$STATE_FILE" ]]; then
            state="SERVER"
            state_color="$green"
            local start_time
            start_time=$(awk -F= '/^START_TIME/ {print $2}' "$STATE_FILE" 2>/dev/null || echo "0")
            local elapsed=$(( $(date +%s) - start_time ))
            local hours=$((elapsed / 3600))
            local mins=$(((elapsed % 3600) / 60))
            uptime_str="${hours}h ${mins}m"
            activated_by=$(awk -F= '/^USER/ {print $2}' "$STATE_FILE" 2>/dev/null || echo "unknown")
        fi

        # CPU & Memory
        local cpu_usage
        cpu_usage=$(awk '/^cpu / {printf "%.0f", 100 - ($5 * 100 / ($2+$3+$4+$5+$6+$7+$8))}' /proc/stat 2>/dev/null || echo "?")
        local mem_info
        mem_info=$(free -g 2>/dev/null | awk '/^Mem:/ {printf "%d / %d GB", $3, $2}')
        local cpu_epp
        cpu_epp=$(cat /sys/devices/system/cpu/cpu0/cpufreq/energy_performance_preference 2>/dev/null || echo "N/A")

        # GPU (with timeout protection)
        local gpu_util="—" gpu_mem="—" gpu_power="—"
        if command -v nvidia-smi &>/dev/null; then
            local gpu_info
            gpu_info=$(timeout 1 nvidia-smi --query-gpu=utilization.gpu,memory.used,memory.total,power.draw --format=csv,noheader,nounits 2>/dev/null || echo "")
            if [[ -n "$gpu_info" ]]; then
                gpu_util=$(echo "$gpu_info" | awk -F', ' '{printf "%d%%", $1}')
                gpu_mem=$(echo "$gpu_info" | awk -F', ' '{printf "%.1f / %.0f GB", $2/1024, $3/1024}')
                gpu_power=$(echo "$gpu_info" | awk -F', ' '{printf "%.0fW", $4}')
            fi
        fi

        # Active tmux sessions
        local tmux_sessions=""
        if command -v tmux &>/dev/null; then
            tmux_sessions=$(tmux list-sessions -F "#{session_name}: #{session_windows} win" 2>/dev/null | head -3 || echo "")
        fi

        # Active SSH connections (excluding our own)
        local ssh_connections
        ssh_connections=$(who 2>/dev/null | grep -v "tty[0-9]" | awk '{print $1"@"$5}' | head -3 || echo "")

        # Build display
        printf '%s' "$clear_screen"

        echo "${bold}╭─────────────────────────────────────────────────────────╮${reset}"
        printf "${bold}│${reset}  ${state_color}${bold}%-14s${reset}                          ${dim}v%-8s${reset}${bold}│${reset}\n" "$state MODE" "$VERSION"
        echo "${bold}├─────────────────────────────────────────────────────────┤${reset}"
        printf "${bold}│${reset}  ${dim}Uptime:${reset}      %-40s${bold}│${reset}\n" "$uptime_str"
        printf "${bold}│${reset}  ${dim}Activated:${reset}   %-40s${bold}│${reset}\n" "$activated_by"
        printf "${bold}│${reset}  ${dim}CPU EPP:${reset}     %-40s${bold}│${reset}\n" "$cpu_epp"
        echo "${bold}├─────────────────────────────────────────────────────────┤${reset}"
        printf "${bold}│${reset}  ${cyan}SYSTEM${reset}                                              ${bold}│${reset}\n"
        printf "${bold}│${reset}    CPU:  %-3s%%          Mem: %-24s${bold}│${reset}\n" "$cpu_usage" "$mem_info"
        if [[ "$gpu_util" != "—" ]]; then
            printf "${bold}│${reset}    GPU:  %-6s        VRAM: %-22s${bold}│${reset}\n" "$gpu_util" "$gpu_mem"
            printf "${bold}│${reset}    Power: %-44s${bold}│${reset}\n" "$gpu_power"
        fi
        echo "${bold}├─────────────────────────────────────────────────────────┤${reset}"
        printf "${bold}│${reset}  ${cyan}SESSIONS${reset}                                            ${bold}│${reset}\n"
        if [[ -n "$tmux_sessions" ]]; then
            while IFS= read -r sess; do
                printf "${bold}│${reset}    ${green}tmux:${reset} %-44s${bold}│${reset}\n" "$sess"
            done <<< "$tmux_sessions"
        else
            printf "${bold}│${reset}    ${dim}No tmux sessions${reset}                                  ${bold}│${reset}\n"
        fi
        if [[ -n "$ssh_connections" ]]; then
            while IFS= read -r conn; do
                printf "${bold}│${reset}    ${yellow}ssh:${reset}  %-44s${bold}│${reset}\n" "$conn"
            done <<< "$ssh_connections"
        fi
        echo "${bold}├─────────────────────────────────────────────────────────┤${reset}"
        printf "${bold}│${reset}  ${bold}[R]${reset}estore Desktop    ${bold}[S]${reset}hutdown    ${bold}[Q]${reset}uit              ${bold}│${reset}\n"
        echo "${bold}╰─────────────────────────────────────────────────────────╯${reset}"

        # Read single keypress with timeout for refresh
        local key=""
        read -rsn1 -t "$refresh_interval" key || true

        case "${key,,}" in  # lowercase
            r)
                tput cnorm 2>/dev/null
                printf '\n%s' "${yellow}Restore desktop? [y/N]: ${reset}"
                read -rsn1 confirm
                if [[ "${confirm,,}" == "y" ]]; then
                    trap - EXIT
                    echo ""
                    exec "$SCRIPT_PATH" restore
                fi
                ;;
            s)
                tput cnorm 2>/dev/null
                printf '\n%s' "${red}Shut down computer? [y/N]: ${reset}"
                read -rsn1 confirm
                if [[ "${confirm,,}" == "y" ]]; then
                    trap - EXIT
                    echo ""
                    echo "Shutting down..."
                    systemctl poweroff
                fi
                ;;
            q)
                tput cnorm 2>/dev/null
                trap - EXIT
                echo ""
                exit 0
                ;;
        esac
    done
}

cmd_check() {
    local check_script="$(dirname "$SCRIPT_PATH")/server-mode-check"

    if [[ ! -x "$check_script" ]]; then
        err "Pre-flight check script not found: $check_script"
        exit 1
    fi

    # Run the comprehensive external checker
    if ! "$check_script"; then
        exit 1
    fi

    echo ""
    echo -e "\033[1mWhat 'server-mode on' will do:\033[0m"
    echo "  1. Run pre-flight safety checks"
    echo "  2. Switch to multi-user.target (stops desktop)"
    echo "  3. Verify transition succeeded (multi-user active, DM stopped)"
    echo ""
    echo -e "\033[1mRecovery:\033[0m"
    echo "  - All changes revert on reboot (state in /run)"
    echo "  - Run 'server-mode restore' to restore desktop"
    echo "  - Safety timer auto-restores after ${SAFETY_TIMEOUT}s if SSH session"
    echo ""
}

# ------------------------------------------------------------------------------
# Entry Point
# ------------------------------------------------------------------------------

# Allow script to be sourced by systemd-run
if [[ "${BASH_SOURCE[0]}" != "$0" ]]; then
    return 0
fi

case "${1:-status}" in
    on|enable|enter)
        cmd_on
        ;;
    restore|off|disable|exit)
        cmd_off
        ;;
    status|info)
        cmd_status
        ;;
    console|tty|ui)
        cmd_console
        ;;
    check|preflight|dry-run)
        cmd_check
        ;;
    *)
        echo "Usage: $0 {on|restore|status|console|check}"
        echo ""
        echo "Commands:"
        echo "  on       Enter server mode (stop desktop, low power)"
        echo "  restore  Exit server mode (restore desktop)"
        echo "  status   Show current state and configuration"
        echo "  console  Interactive dashboard with quick actions"
        echo "  check    Run pre-flight checks without making changes"
        exit 1
        ;;
esac
